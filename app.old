from fastapi import FastAPI, Request
from fastapi.responses import StreamingResponse
from fastapi.middleware.cors import CORSMiddleware
import httpx
import json
import logging
import sys
import os
from typing import Dict, Any
import sqlite3
from pydantic import BaseModel

logging.basicConfig(
    level=logging.DEBUG,
    format='%(asctime)s - %(levelname)s - %(message)s',
    handlers=[logging.StreamHandler(sys.stdout)]
)
logger = logging.getLogger(__name__)

app = FastAPI()

app.add_middleware(
    CORSMiddleware,
    allow_origins=["*"],
    allow_methods=["*"],
    allow_headers=["*"],
)

OLLAMA_URL = "http://192.168.1.166:11434"
FLOWISE_URL = "http://192.168.1.166:3000"
TIMEOUT_CONFIG = httpx.Timeout(timeout=300.0)
DATABASE_URL = os.getenv('DATABASE_URL', '/data/keywords.db')

# Upewnij się, że katalog istnieje
os.makedirs(os.path.dirname(DATABASE_URL), exist_ok=True)

def init_db():
    conn = sqlite3.connect(DATABASE_URL)
    c = conn.cursor()
    c.execute('''CREATE TABLE IF NOT EXISTS keywords
                 (id INTEGER PRIMARY KEY AUTOINCREMENT,
                  keyword TEXT NOT NULL,
                  flowise_id TEXT NOT NULL,
                  description TEXT)''')
    conn.commit()
    conn.close()

init_db()

class KeywordRule(BaseModel):
    keyword: str
    flowise_id: str
    description: str = ""

@app.post("/api/keywords")
async def create_keyword(rule: KeywordRule):
    conn = sqlite3.connect(DATABASE_URL)
    c = conn.cursor()
    c.execute('INSERT INTO keywords (keyword, flowise_id, description) VALUES (?, ?, ?)',
              (rule.keyword, rule.flowise_id, rule.description))
    conn.commit()
    id = c.lastrowid
    conn.close()
    return {"id": id, **rule.dict()}

@app.get("/api/keywords")
async def get_keywords():
    conn = sqlite3.connect(DATABASE_URL)
    c = conn.cursor()
    c.execute('SELECT id, keyword, flowise_id, description FROM keywords')
    keywords = [{"id": row[0], "keyword": row[1], "flowise_id": row[2], "description": row[3]} 
                for row in c.fetchall()]
    conn.close()
    return keywords

@app.put("/api/keywords/{keyword_id}")
async def update_keyword(keyword_id: int, rule: KeywordRule):
    conn = sqlite3.connect(DATABASE_URL)
    c = conn.cursor()
    c.execute('UPDATE keywords SET keyword=?, flowise_id=?, description=? WHERE id=?',
              (rule.keyword, rule.flowise_id, rule.description, keyword_id))
    conn.commit()
    conn.close()
    return {"id": keyword_id, **rule.dict()}

@app.delete("/api/keywords/{keyword_id}")
async def delete_keyword(keyword_id: int):
    conn = sqlite3.connect(DATABASE_URL)
    c = conn.cursor()
    c.execute('DELETE FROM keywords WHERE id=?', (keyword_id,))
    conn.commit()
    conn.close()
    return {"status": "success"}

@app.post("/api/chat")
async def chat(request: Request):
    print("Otrzymano zapytanie chat", flush=True)
    try:
        data = await request.json()
        messages = data.get("messages", [])
        last_message = messages[-1].get("content", "").lower() if messages else ""
        
        # Sprawdzanie słów kluczowych z bazy danych
        conn = sqlite3.connect(DATABASE_URL)
        c = conn.cursor()
        c.execute('SELECT keyword, flowise_id FROM keywords')
        keywords = c.fetchall()
        conn.close()

        for keyword, flowise_id in keywords:
            if keyword.lower() in last_message:
                try:
                    async with httpx.AsyncClient(timeout=TIMEOUT_CONFIG) as client:
                        flowise_response = await client.post(
                            f"{FLOWISE_URL}/api/v1/prediction/{flowise_id}",
                            json={"question": last_message}
                        )
                        return StreamingResponse(
                            iter([json.dumps({
                                "model": "flowise",
                                "message": {
                                    "role": "assistant",
                                    "content": flowise_response.json().get("text", "Brak odpowiedzi")
                                },
                                "done": True
                            }) + "\n"]),
                            media_type="application/x-ndjson"
                        )
                except Exception as e:
                    print(f"Błąd Flowise: {str(e)}", flush=True)

        # Jeśli nie znaleziono pasującego słowa kluczowego, przekieruj do Ollama
        async def generate():
            async with httpx.AsyncClient(timeout=TIMEOUT_CONFIG) as client:
                async with client.stream("POST", f"{OLLAMA_URL}/api/chat", json=data) as response:
                    async for line in response.aiter_lines():
                        if line.strip():
                            yield line + "\n"

        return StreamingResponse(
            generate(),
            media_type="application/x-ndjson"
        )
            
    except Exception as e:
        print(f"BŁĄD GŁÓWNY: {str(e)}", flush=True)
        logger.error("Szczegóły błędu:", exc_info=True)
        return StreamingResponse(
            iter([json.dumps({"error": str(e)}) + "\n"]),
            media_type="application/x-ndjson"
        )
